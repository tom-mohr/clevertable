from typing import Callable

from .Converter import Converter


class StrictFunction(Converter):

    def __init__(self, transform: callable, labels: Callable[[any], any] = None):
        """
        Creates a custom converter from a custom ``transform()`` function
        (and optionally, a custom ``labels()`` function).
        This is a handy way to create a converter that doesn't implement ``fit()`` (i.e. doesn't have a state).
        Both ``transform`` and ``labels`` must both accept and return lists.
        For a converter that accepts more general functions, see ``Function``.

        If no custom labels function is given, the output labels are generated based on the
        output cardinality inferred during ``fit()`` and according to the following logic:

        - If the number of incoming labels is identical to the output cardinality,
          the labels will be returned unchanged.
        - Otherwise, the number of incoming labels must be 1 and the output labels are generated by adding suffixes
          ``_0``, ``_1``, etc. to the single input label.

        A special case are functions returning output of varying cardinality during ``fit()``.
        In this case, a single input label is returned.
        If multiple input labels are given, they are joined with ``_``.

        :param transform: The function to wrap. Turns input into output.
        :param labels: Turns incoming labels into output labels.
        """
        self._transform = transform
        self._labels = labels

        self._output_cardinality: int = None

    def fit(self, rows: list[list]):
        # infer output cardinality (only needed if no labels function is given)
        if self._labels is None:
            rows = [self._transform(row) for row in rows]
            self._output_cardinality = len(rows[0])

            # check if output cardinality varies:
            if not all(len(row) == self._output_cardinality for row in rows):
                self._output_cardinality = -1  # a value of -1 represents varying output cardinality
                return

    def transform(self, row: list) -> list:
        return self._transform(row)

    def labels(self, labels: list) -> list:
        if self._labels is None:

            if self._output_cardinality == -1:
                # -1 represents varying output cardinality
                return ["_".join(labels)]

            if len(labels) == self._output_cardinality:
                return labels

            # generate label names:

            if self._output_cardinality == 0:
                # can do this even for len(labels) != 1
                return []
            assert len(labels) == 1, \
                f"The needed {self._output_cardinality} labels for function {self._transform.__name__}" \
                f"can only be generated from a single input label, but received {repr(labels)}."
            label = labels[0]
            return [f"{label}_{i}" for i in range(self._output_cardinality)]
        else:
            # use custom labels function
            return self._labels(labels)

    def __repr__(self):
        args = [self._transform.__name__]
        if self._labels is not None:
            args.append(self._labels.__name__)
        return f"StrictFunction({', '.join(args)})"
